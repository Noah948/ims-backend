PROJECT: SaaS Inventory Management System
STACK: FastAPI + SQLAlchemy 2.0 ORM + PostgreSQL
ARCHITECTURE STYLE: Multi-tenant, Soft-delete aware, Ownership-based isolation
AUDIT SYSTEM: Event-driven, ORM-level automatic logging


============================================================
1. TABLE LIST
============================================================

Core Tenant Table:
- users

Business Domain Tables:
- products
- categories
- category_fields
- sales
- teams
- jobs
- payments

System Tables:
- audit_logs


============================================================
2. PRIMARY RELATIONSHIPS
============================================================

User (Tenant Root)
- has many Teams
- has many Products
- has many Sales
- has many Payments
- has many Jobs
- has many Categories
- has many AuditLogs

Category
- belongs to User
- has many CategoryFields
- has many Products

CategoryField
- belongs to Category

Product
- belongs to User
- belongs to Category (nullable)
- has many Sales

Sale
- belongs to User
- belongs to Product

Team
- belongs to User

Job
- belongs to User

Payment
- belongs to User

AuditLog
- belongs to User
- stores entity_type
- stores entity_id
- stores operation (CREATE | UPDATE | DELETE)
- stores created_at timestamp


============================================================
3. MULTI-TENANT RULES
============================================================

Tenant Isolation Strategy: Ownership-based via user_id

Tables requiring direct user_id:
- teams
- products
- sales
- payments
- jobs
- categories
- audit_logs

Tables indirectly tenant-scoped:
- category_fields (via category → user)
- sales (via product + user)

Rules:
- All business queries must filter by user_id.
- No cross-user joins allowed.
- Foreign keys use ON DELETE CASCADE to prevent orphaned tenant data.
- Audit logs are also tenant-isolated via user_id.
- Audit system never exposes cross-tenant operations.


============================================================
4. SOFT DELETE vs HARD DELETE
============================================================

Soft Delete:
- users (deleted_at)
- products (deleted_at)

Soft Delete Behavior:
- UPDATE operation is logged in audit_logs.
- Historical sales remain intact.
- Product remains for financial reporting.

Hard Delete:
- teams
- jobs
- category_fields
- categories (if safe)
- sales (optional, depending on policy)
- payments (optional)

Important:
- Products are soft deleted to preserve historical Sales.
- Sales are immutable financial records.
- Audit logs capture DELETE events for traceability.


============================================================
5. CASCADE RULES
============================================================

ON DELETE CASCADE:
- user → teams
- user → products
- user → sales
- user → payments
- user → jobs
- user → categories
- user → audit_logs
- category → category_fields
- product → sales

ON DELETE SET NULL:
- product.category_id

Purpose:
- Prevent orphaned records.
- Maintain ownership integrity.
- Ensure tenant cleanup consistency.
- Keep audit trail tenant-contained.


============================================================
6. IMPORTANT ARCHITECTURAL DECISIONS
============================================================

1. Sales Are Immutable Financial Records
   - profit_loss stored at time of sale.
   - Product price changes do NOT affect past sales.
   - Sales never auto-recalculate.

2. Inventory Logic
   - Stock reduces at sale creation.
   - Sale blocked if stock < quantity.
   - minimum_stock supports alerts.
   - Stock changes can be audited.

3. Soft Delete Strategy
   - Products retained for reporting.
   - Users soft-deletable for compliance.
   - Deletion events logged automatically.

4. JSONB Dynamic Fields
   - products.dynamic_fields enables category-driven schema flexibility.
   - No table migration needed for new product attributes.

5. Counters in User
   - total_products
   - out_of_stock_count
   - low_stock_count
   Optimized for dashboard performance.

6. Selectin Loading
   - lazy="selectin" prevents N+1 queries.
   - Optimized for SaaS dashboards.

7. UUID Primary Keys
   - All tables use UUID.
   - Scalable for distributed systems.

8. Automatic ORM-Level Audit Logging
   - Implemented using SQLAlchemy session events.
   - Triggers on:
       CREATE
       UPDATE (column-level detection)
       DELETE
   - Automatically extracts user_id (direct or via FK).
   - Fully model-agnostic.
   - No manual logging required in services.
   - Works for all tenant-scoped tables.

9. Event-Driven Logging Architecture
   - Audit logs generated in after_flush event.
   - Prevents duplicate logs.
   - Safe during transaction rollback.
   - Cleared automatically post-flush.


============================================================
7. ENUMS / CONSTRAINTS IMPACTING DESIGN
============================================================

Payment.status:
- active
- cancelled
- expired

Business Type (User.business_type):
- general (default)
- extendable for vertical-specific SaaS

Integrity Constraints:
- email unique in users
- NOT NULL on ownership columns
- Foreign keys enforce tenant isolation
- Audit logs require valid user_id


============================================================
8. AUDIT SYSTEM SUMMARY
============================================================

The system includes a global automatic audit mechanism where:

- Every CREATE, UPDATE, DELETE operation is logged.
- Logging is automatic via SQLAlchemy events.
- No manual logging required in business services.
- Audit logs are tenant-isolated.
- Logs are safe from recursive logging.
- Designed for ERP-grade traceability.

Current Scope:
- Operation-level tracking.

Future Upgrade Path:
- Field-level diff tracking
- Old vs new value storage
- Soft-delete flag detection
- Actor metadata (IP, device)
- Role-based audit filtering


============================================================
SYSTEM SUMMARY
============================================================

This system is a production-ready multi-tenant SaaS inventory platform where:

- User is the tenant root.
- All business data belongs to a user.
- Products and Sales are operational core tables.
- Sales are immutable financial history.
- Soft delete preserves historical integrity.
- JSONB enables flexible product schema.
- Cascades maintain ownership integrity.
- Automatic audit logging ensures traceability.
- Designed for scalability and horizontal growth.

End of Updated Schema Summary.
